<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criatura de Terror</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<script>
var Input = {
    keys: [],
    mouse: {
      left: false,
      right: false,
      middle: false,
      x: 0,
      y: 0
    }
  };
  for (var i = 0; i < 230; i++) {
    Input.keys.push(false);
  }
  document.addEventListener("keydown", function(event) {
    Input.keys[event.keyCode] = true;
  });
  document.addEventListener("keyup", function(event) {
    Input.keys[event.keyCode] = false;
  });
  document.addEventListener("mousedown", function(event) {
    if ((event.button = 0)) {
      Input.mouse.left = true;
    }
    if ((event.button = 1)) {
      Input.mouse.middle = true;
    }
    if ((event.button = 2)) {
      Input.mouse.right = true;
    }
  });
  document.addEventListener("mouseup", function(event) {
    if ((event.button = 0)) {
      Input.mouse.left = false;
    }
    if ((event.button = 1)) {
      Input.mouse.middle = false;
    }
    if ((event.button = 2)) {
      Input.mouse.right = false;
    }
  });
  document.addEventListener("mousemove", function(event) {
    Input.mouse.x = event.clientX;
    Input.mouse.y = event.clientY;
  });
  
  //Sets up canvas
  var canvas = document.createElement("canvas");
  document.body.appendChild(canvas);
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  canvas.style.position = "absolute";
  canvas.style.left = "0px";
  canvas.style.top = "0px";
  var ctx = canvas.getContext("2d");
  
  // Variables para efectos de fondo
  var time = 0;
  var particles = [];
  
  // Crear partículas flotantes
  for (var i = 0; i < 50; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 3 + 1,
      speedX: (Math.random() - 0.5) * 0.5,
      speedY: (Math.random() - 0.5) * 0.5,
      opacity: Math.random() * 0.5 + 0.2
    });
  }
  
  // Función para dibujar fondo tétrico
  function drawHorrorBackground() {
    // Gradiente de fondo oscuro
    var gradient = ctx.createRadialGradient(
      canvas.width / 2, canvas.height / 2, 0,
      canvas.width / 2, canvas.height / 2, canvas.width
    );
    gradient.addColorStop(0, '#1a0a0a');
    gradient.addColorStop(0.5, '#0d0000');
    gradient.addColorStop(1, '#000000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Niebla ondulante
    ctx.save();
    ctx.globalAlpha = 0.15;
    for (var i = 0; i < 5; i++) {
      ctx.fillStyle = '#440000';
      ctx.beginPath();
      for (var x = 0; x < canvas.width; x += 20) {
        var y = canvas.height * 0.7 + Math.sin(x * 0.01 + time * 0.5 + i) * 50;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.lineTo(0, canvas.height);
      ctx.fill();
    }
    ctx.restore();
    
    // Partículas flotantes (cenizas/almas)
    particles.forEach(function(p) {
      p.x += p.speedX;
      p.y += p.speedY;
      
      if (p.x < 0) p.x = canvas.width;
      if (p.x > canvas.width) p.x = 0;
      if (p.y < 0) p.y = canvas.height;
      if (p.y > canvas.height) p.y = 0;
      
      ctx.save();
      ctx.globalAlpha = p.opacity * (0.5 + Math.sin(time * 2 + p.x) * 0.5);
      ctx.fillStyle = '#ff6666';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }
  
  // Función para dibujar silueta de dragón
  function drawDragonSilhouette() {
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#220000';
    
    var centerX = canvas.width * 0.8;
    var centerY = canvas.height * 0.3;
    var breathOffset = Math.sin(time) * 10;
    
    // Cuerpo del dragón
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, 100, 60, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Cabeza
    ctx.beginPath();
    ctx.ellipse(centerX + 80, centerY - 20 + breathOffset, 50, 40, -0.3, 0, Math.PI * 2);
    ctx.fill();
    
    // Cuerno superior
    ctx.beginPath();
    ctx.moveTo(centerX + 100, centerY - 40 + breathOffset);
    ctx.lineTo(centerX + 110, centerY - 70 + breathOffset);
    ctx.lineTo(centerX + 95, centerY - 35 + breathOffset);
    ctx.fill();
    
    // Cuerno inferior
    ctx.beginPath();
    ctx.moveTo(centerX + 95, centerY - 30 + breathOffset);
    ctx.lineTo(centerX + 105, centerY - 55 + breathOffset);
    ctx.lineTo(centerX + 90, centerY - 25 + breathOffset);
    ctx.fill();
    
    // Ojo brillante
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(centerX + 95, centerY - 25 + breathOffset, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Resplandor del ojo
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.arc(centerX + 95, centerY - 25 + breathOffset, 12, 0, Math.PI * 2);
    ctx.fill();
    
    // Alas
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = '#330000';
    ctx.beginPath();
    ctx.moveTo(centerX - 20, centerY);
    ctx.quadraticCurveTo(centerX - 100, centerY - 100, centerX - 150, centerY - 50);
    ctx.quadraticCurveTo(centerX - 120, centerY - 20, centerX - 40, centerY + 20);
    ctx.fill();
    
    ctx.beginPath();
    ctx.moveTo(centerX - 20, centerY);
    ctx.quadraticCurveTo(centerX - 80, centerY + 80, centerX - 130, centerY + 100);
    ctx.quadraticCurveTo(centerX - 100, centerY + 60, centerX - 40, centerY + 30);
    ctx.fill();
    
    // Cola
    ctx.globalAlpha = 0.25;
    ctx.strokeStyle = '#220000';
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.moveTo(centerX - 100, centerY + 30);
    ctx.quadraticCurveTo(centerX - 200, centerY + 100, centerX - 250, centerY + 80);
    ctx.stroke();
    
    ctx.restore();
  }
  

  
  //Necessary classes
  var segmentCount = 0;
  class Segment {
    constructor(parent, size, angle, range, stiffness) {
      segmentCount++;
      this.isSegment = true;
      this.parent = parent;
      if (typeof parent.children == "object") {
        parent.children.push(this);
      }
      this.children = [];
      this.size = size;
      this.relAngle = angle;
      this.defAngle = angle;
      this.absAngle = parent.absAngle + angle;
      this.range = range;
      this.stiffness = stiffness;
      this.updateRelative(false, true);
    }
    updateRelative(iter, flex) {
      this.relAngle =
        this.relAngle -
        2 *
          Math.PI *
          Math.floor((this.relAngle - this.defAngle) / 2 / Math.PI + 1 / 2);
      if (flex) {
        this.relAngle = Math.min(
          this.defAngle + this.range / 2,
          Math.max(
            this.defAngle - this.range / 2,
            (this.relAngle - this.defAngle) / this.stiffness + this.defAngle
          )
        );
      }
      this.absAngle = this.parent.absAngle + this.relAngle;
      this.x = this.parent.x + Math.cos(this.absAngle) * this.size;
      this.y = this.parent.y + Math.sin(this.absAngle) * this.size;
      if (iter) {
        for (var i = 0; i < this.children.length; i++) {
          this.children[i].updateRelative(iter, flex);
        }
      }
    }
    draw(iter) {
      // Determinar si este segmento es parte de la cola
      var isPartOfTail = this.children.length <= 2;
      
      // Ajustar grosor según si es cola o cuerpo
      var segmentWidth = isPartOfTail ? 1.5 : 3;
      
      // Efecto de brillo en los segmentos
      var gradient = ctx.createLinearGradient(
        this.parent.x, this.parent.y,
        this.x, this.y
      );
      gradient.addColorStop(0, '#ff4444');
      gradient.addColorStop(0.5, '#ff0000');
      gradient.addColorStop(1, '#cc0000');
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = segmentWidth;
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 5;
      
      // Línea principal del segmento
      ctx.beginPath();
      ctx.moveTo(this.parent.x, this.parent.y);
      ctx.lineTo(this.x, this.y);
      ctx.stroke();
      
      // Dibujar costillas esqueléticas si NO es cola
      if (!isPartOfTail && this.children.length > 2) {
        var angle = Math.atan2(this.y - this.parent.y, this.x - this.parent.x);
        var perpAngle = angle + Math.PI / 2;
        var midX = (this.parent.x + this.x) / 2;
        var midY = (this.parent.y + this.y) / 2;
        
        ctx.strokeStyle = '#ff3333';
        ctx.lineWidth = 1.5;
        
        // Costillas laterales
        var ribLength = 12;
        
        // Costilla izquierda
        ctx.beginPath();
        ctx.moveTo(midX, midY);
        ctx.lineTo(
          midX + Math.cos(perpAngle) * ribLength,
          midY + Math.sin(perpAngle) * ribLength
        );
        ctx.stroke();
        
        // Costilla derecha
        ctx.beginPath();
        ctx.moveTo(midX, midY);
        ctx.lineTo(
          midX - Math.cos(perpAngle) * ribLength,
          midY - Math.sin(perpAngle) * ribLength
        );
        ctx.stroke();
      }
      
      // Si es la cola, agregar segmentos más delgados
      if (isPartOfTail && this.children.length > 0) {
        var angle = Math.atan2(this.y - this.parent.y, this.x - this.parent.x);
        var perpAngle = angle + Math.PI / 2;
        var midX = (this.parent.x + this.x) / 2;
        var midY = (this.parent.y + this.y) / 2;
        
        ctx.strokeStyle = '#ff3333';
        ctx.lineWidth = 1;
        
        // Pequeñas marcas en la cola
        var markLength = 4;
        ctx.beginPath();
        ctx.moveTo(midX + Math.cos(perpAngle) * markLength, midY + Math.sin(perpAngle) * markLength);
        ctx.lineTo(midX - Math.cos(perpAngle) * markLength, midY - Math.sin(perpAngle) * markLength);
        ctx.stroke();
      }
      
      // Si es el último segmento, simplemente dibujar un pequeño punto
      if (this.children.length === 0) {
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff0000';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.shadowBlur = 0;
      
      if (iter) {
        for (var i = 0; i < this.children.length; i++) {
          this.children[i].draw(true);
        }
      }
    }
    follow(iter) {
      var x = this.parent.x;
      var y = this.parent.y;
      var dist = ((this.x - x) ** 2 + (this.y - y) ** 2) ** 0.5;
      this.x = x + this.size * (this.x - x) / dist;
      this.y = y + this.size * (this.y - y) / dist;
      this.absAngle = Math.atan2(this.y - y, this.x - x);
      this.relAngle = this.absAngle - this.parent.absAngle;
      this.updateRelative(false, true);
      if (iter) {
        for (var i = 0; i < this.children.length; i++) {
          this.children[i].follow(true);
        }
      }
    }
  }
  
  class LimbSystem {
    constructor(end, length, speed, creature) {
      this.end = end;
      this.length = Math.max(1, length);
      this.creature = creature;
      this.speed = speed;
      creature.systems.push(this);
      this.nodes = [];
      var node = end;
      for (var i = 0; i < length; i++) {
        this.nodes.unshift(node);
        node = node.parent;
        if (!node.isSegment) {
          this.length = i + 1;
          break;
        }
      }
      this.hip = this.nodes[0].parent;
    }
    moveTo(x, y) {
      this.nodes[0].updateRelative(true, true);
      var dist = ((x - this.end.x) ** 2 + (y - this.end.y) ** 2) ** 0.5;
      var len = Math.max(0, dist - this.speed);
      for (var i = this.nodes.length - 1; i >= 0; i--) {
        var node = this.nodes[i];
        var ang = Math.atan2(node.y - y, node.x - x);
        node.x = x + len * Math.cos(ang);
        node.y = y + len * Math.sin(ang);
        x = node.x;
        y = node.y;
        len = node.size;
      }
      for (var i = 0; i < this.nodes.length; i++) {
        var node = this.nodes[i];
        node.absAngle = Math.atan2(
          node.y - node.parent.y,
          node.x - node.parent.x
        );
        node.relAngle = node.absAngle - node.parent.absAngle;
        for (var ii = 0; ii < node.children.length; ii++) {
          var childNode = node.children[ii];
          if (!this.nodes.includes(childNode)) {
            childNode.updateRelative(true, false);
          }
        }
      }
    }
    update() {
      this.moveTo(Input.mouse.x, Input.mouse.y);
    }
  }
  
  class LegSystem extends LimbSystem {
    constructor(end, length, speed, creature) {
      super(end, length, speed, creature);
      this.goalX = end.x;
      this.goalY = end.y;
      this.step = 0;
      this.forwardness = 0;
      this.reach =
        0.9 *
        ((this.end.x - this.hip.x) ** 2 + (this.end.y - this.hip.y) ** 2) ** 0.5;
      var relAngle =
        this.creature.absAngle -
        Math.atan2(this.end.y - this.hip.y, this.end.x - this.hip.x);
      relAngle -= 2 * Math.PI * Math.floor(relAngle / 2 / Math.PI + 1 / 2);
      this.swing = -relAngle + (2 * (relAngle < 0) - 1) * Math.PI / 2;
      this.swingOffset = this.creature.absAngle - this.hip.absAngle;
    }
    update(x, y) {
      this.moveTo(this.goalX, this.goalY);
      if (this.step == 0) {
        var dist =
          ((this.end.x - this.goalX) ** 2 + (this.end.y - this.goalY) ** 2) **
          0.5;
        if (dist > 1) {
          this.step = 1;
          this.goalX =
            this.hip.x +
            this.reach *
              Math.cos(this.swing + this.hip.absAngle + this.swingOffset) +
            (2 * Math.random() - 1) * this.reach / 2;
          this.goalY =
            this.hip.y +
            this.reach *
              Math.sin(this.swing + this.hip.absAngle + this.swingOffset) +
            (2 * Math.random() - 1) * this.reach / 2;
        }
      } else if (this.step == 1) {
        var theta =
          Math.atan2(this.end.y - this.hip.y, this.end.x - this.hip.x) -
          this.hip.absAngle;
        var dist =
          ((this.end.x - this.hip.x) ** 2 + (this.end.y - this.hip.y) ** 2) **
          0.5;
        var forwardness2 = dist * Math.cos(theta);
        var dF = this.forwardness - forwardness2;
        this.forwardness = forwardness2;
        if (dF * dF < 1) {
          this.step = 0;
          this.goalX = this.hip.x + (this.end.x - this.hip.x);
          this.goalY = this.hip.y + (this.end.y - this.hip.y);
        }
      }
    }
  }
  
  class Creature {
    constructor(
      x,
      y,
      angle,
      fAccel,
      fFric,
      fRes,
      fThresh,
      rAccel,
      rFric,
      rRes,
      rThresh
    ) {
      this.x = x;
      this.y = y;
      this.absAngle = angle;
      this.fSpeed = 0;
      this.fAccel = fAccel;
      this.fFric = fFric;
      this.fRes = fRes;
      this.fThresh = fThresh;
      this.rSpeed = 0;
      this.rAccel = rAccel;
      this.rFric = rFric;
      this.rRes = rRes;
      this.rThresh = rThresh;
      this.children = [];
      this.systems = [];
    }
    follow(x, y) {
      var dist = ((this.x - x) ** 2 + (this.y - y) ** 2) ** 0.5;
      var angle = Math.atan2(y - this.y, x - this.x);
      var accel = this.fAccel;
      if (this.systems.length > 0) {
        var sum = 0;
        for (var i = 0; i < this.systems.length; i++) {
          sum += this.systems[i].step == 0;
        }
        accel *= sum / this.systems.length;
      }
      this.fSpeed += accel * (dist > this.fThresh);
      this.fSpeed *= 1 - this.fRes;
      this.speed = Math.max(0, this.fSpeed - this.fFric);
      var dif = this.absAngle - angle;
      dif -= 2 * Math.PI * Math.floor(dif / (2 * Math.PI) + 1 / 2);
      if (Math.abs(dif) > this.rThresh && dist > this.fThresh) {
        this.rSpeed -= this.rAccel * (2 * (dif > 0) - 1);
      }
      this.rSpeed *= 1 - this.rRes;
      if (Math.abs(this.rSpeed) > this.rFric) {
        this.rSpeed -= this.rFric * (2 * (this.rSpeed > 0) - 1);
      } else {
        this.rSpeed = 0;
      }
      this.absAngle += this.rSpeed;
      this.absAngle -=
        2 * Math.PI * Math.floor(this.absAngle / (2 * Math.PI) + 1 / 2);
      this.x += this.speed * Math.cos(this.absAngle);
      this.y += this.speed * Math.sin(this.absAngle);
      this.absAngle += Math.PI;
      for (var i = 0; i < this.children.length; i++) {
        this.children[i].follow(true, true);
      }
      for (var i = 0; i < this.systems.length; i++) {
        this.systems[i].update(x, y);
      }
      this.absAngle -= Math.PI;
      this.draw(true);
    }
    draw(iter) {
      var r = 8;
      var headSize = 25;
      
      ctx.save();
      
      // Cabeza de dragón guerrero
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 20;
      
      // Calcular posición adelante del cuerpo
      var headX = this.x + Math.cos(this.absAngle) * headSize * 0.8;
      var headY = this.y + Math.sin(this.absAngle) * headSize * 0.8;
      
      // Cuello más grueso
      ctx.strokeStyle = '#990000';
      ctx.lineWidth = 12;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(headX, headY);
      ctx.stroke();
      
      // Cráneo principal - más angular y amenazante
      ctx.fillStyle = '#8b0000';
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 2;
      
      // Parte trasera del cráneo
      ctx.beginPath();
      ctx.ellipse(headX - Math.cos(this.absAngle) * 5, headY - Math.sin(this.absAngle) * 5, 
                  headSize * 0.9, headSize * 0.7, this.absAngle, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Hocico largo y angular
      var snoutX = headX + Math.cos(this.absAngle) * headSize * 1.2;
      var snoutY = headY + Math.sin(this.absAngle) * headSize * 1.2;
      
      // Mandíbula superior
      ctx.beginPath();
      var perpAngle = this.absAngle + Math.PI / 2;
      ctx.moveTo(headX + Math.cos(perpAngle) * 10, headY + Math.sin(perpAngle) * 10);
      ctx.lineTo(snoutX + Math.cos(perpAngle) * 6, snoutY + Math.sin(perpAngle) * 6);
      ctx.lineTo(snoutX + Math.cos(this.absAngle) * 8, snoutY + Math.sin(this.absAngle) * 8);
      ctx.lineTo(snoutX - Math.cos(perpAngle) * 6, snoutY - Math.sin(perpAngle) * 6);
      ctx.lineTo(headX - Math.cos(perpAngle) * 10, headY - Math.sin(perpAngle) * 10);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Mandíbula inferior
      ctx.fillStyle = '#660000';
      ctx.beginPath();
      ctx.moveTo(headX + Math.cos(perpAngle) * 8, headY + Math.sin(perpAngle) * 8);
      ctx.lineTo(snoutX + Math.cos(perpAngle) * 5, snoutY + Math.sin(perpAngle) * 5);
      ctx.lineTo(snoutX + Math.cos(this.absAngle) * 8, snoutY + Math.sin(this.absAngle) * 8);
      ctx.lineTo(snoutX - Math.cos(perpAngle) * 5, snoutY - Math.sin(perpAngle) * 5);
      ctx.lineTo(headX - Math.cos(perpAngle) * 8, headY - Math.sin(perpAngle) * 8);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Cuernos grandes y curvados
      var hornBaseX = headX - Math.cos(this.absAngle) * headSize * 0.4;
      var hornBaseY = headY - Math.sin(this.absAngle) * headSize * 0.4;
      
      // Cuerno izquierdo - más grande y curvo
      ctx.strokeStyle = '#4d0000';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(hornBaseX + Math.cos(perpAngle) * 12, hornBaseY + Math.sin(perpAngle) * 12);
      var hornMidX1 = hornBaseX + Math.cos(perpAngle) * 25 - Math.cos(this.absAngle) * 10;
      var hornMidY1 = hornBaseY + Math.sin(perpAngle) * 25 - Math.sin(this.absAngle) * 10;
      ctx.quadraticCurveTo(
        hornMidX1, hornMidY1,
        hornBaseX + Math.cos(perpAngle) * 35 - Math.cos(this.absAngle) * 20,
        hornBaseY + Math.sin(perpAngle) * 35 - Math.sin(this.absAngle) * 20
      );
      ctx.stroke();
      
      // Cuerno derecho
      ctx.beginPath();
      ctx.moveTo(hornBaseX - Math.cos(perpAngle) * 12, hornBaseY - Math.sin(perpAngle) * 12);
      var hornMidX2 = hornBaseX - Math.cos(perpAngle) * 25 - Math.cos(this.absAngle) * 10;
      var hornMidY2 = hornBaseY - Math.sin(perpAngle) * 25 - Math.sin(this.absAngle) * 10;
      ctx.quadraticCurveTo(
        hornMidX2, hornMidY2,
        hornBaseX - Math.cos(perpAngle) * 35 - Math.cos(this.absAngle) * 20,
        hornBaseY - Math.sin(perpAngle) * 35 - Math.sin(this.absAngle) * 20
      );
      ctx.stroke();
      
      // Púas pequeñas en la cabeza
      ctx.lineWidth = 3;
      for (var sp = 0; sp < 3; sp++) {
        var spikeX = hornBaseX - Math.cos(this.absAngle) * sp * 8;
        var spikeY = hornBaseY - Math.sin(this.absAngle) * sp * 8;
        ctx.beginPath();
        ctx.moveTo(spikeX + Math.cos(perpAngle) * 8, spikeY + Math.sin(perpAngle) * 8);
        ctx.lineTo(spikeX + Math.cos(perpAngle) * 15, spikeY + Math.sin(perpAngle) * 15);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(spikeX - Math.cos(perpAngle) * 8, spikeY - Math.sin(perpAngle) * 8);
        ctx.lineTo(spikeX - Math.cos(perpAngle) * 15, spikeY - Math.sin(perpAngle) * 15);
        ctx.stroke();
      }
      
      // Ojos brillantes amenazantes
      var eyeX = headX + Math.cos(this.absAngle) * 5;
      var eyeY = headY + Math.sin(this.absAngle) * 5;
      
      // Ojo izquierdo - más alargado y reptiliano
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.ellipse(
        eyeX + Math.cos(perpAngle) * 10,
        eyeY + Math.sin(perpAngle) * 10,
        7, 4, this.absAngle, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Pupila vertical izquierda
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.ellipse(
        eyeX + Math.cos(perpAngle) * 10,
        eyeY + Math.sin(perpAngle) * 10,
        1.5, 4, this.absAngle, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Ojo derecho
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.ellipse(
        eyeX - Math.cos(perpAngle) * 10,
        eyeY - Math.sin(perpAngle) * 10,
        7, 4, this.absAngle, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Pupila vertical derecha
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.ellipse(
        eyeX - Math.cos(perpAngle) * 10,
        eyeY - Math.sin(perpAngle) * 10,
        1.5, 4, this.absAngle, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Colmillos largos y afilados
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      
      // Colmillos superiores
      var fangBase = snoutX + Math.cos(this.absAngle) * 3;
      var fangBaseY = snoutY + Math.sin(this.absAngle) * 3;
      
      ctx.beginPath();
      ctx.moveTo(fangBase + Math.cos(perpAngle) * 8, fangBaseY + Math.sin(perpAngle) * 8);
      ctx.lineTo(fangBase + Math.cos(perpAngle) * 8 + Math.cos(this.absAngle + Math.PI/6) * 15, 
                 fangBaseY + Math.sin(perpAngle) * 8 + Math.sin(this.absAngle + Math.PI/6) * 15);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(fangBase - Math.cos(perpAngle) * 8, fangBaseY - Math.sin(perpAngle) * 8);
      ctx.lineTo(fangBase - Math.cos(perpAngle) * 8 + Math.cos(this.absAngle - Math.PI/6) * 15, 
                 fangBaseY - Math.sin(perpAngle) * 8 + Math.sin(this.absAngle - Math.PI/6) * 15);
      ctx.stroke();
      
      // Dientes más pequeños
      ctx.lineWidth = 2;
      for (var t = -1; t <= 1; t++) {
        if (t === 0) continue;
        ctx.beginPath();
        ctx.moveTo(snoutX + Math.cos(perpAngle) * t * 4, snoutY + Math.sin(perpAngle) * t * 4);
        ctx.lineTo(snoutX + Math.cos(perpAngle) * t * 4 + Math.cos(this.absAngle) * 8, 
                   snoutY + Math.sin(perpAngle) * t * 4 + Math.sin(this.absAngle) * 8);
        ctx.stroke();
      }
      
      // Fosas nasales
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(snoutX + Math.cos(perpAngle) * 4, snoutY + Math.sin(perpAngle) * 4, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(snoutX - Math.cos(perpAngle) * 4, snoutY - Math.sin(perpAngle) * 4, 2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
      
      // Cuerpo
      ctx.strokeStyle = '#ff3333';
      ctx.lineWidth = 3;
      ctx.fillStyle = '#cc0000';
      ctx.beginPath();
      ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      ctx.restore();
      
      if (iter) {
        for (var i = 0; i < this.children.length; i++) {
          this.children[i].draw(true);
        }
      }
    }
  }
  
  //Inicialización
  var critter;
  function setupLizard(size, legs, tail) {
    var s = size;
    critter = new Creature(
      window.innerWidth / 2,
      window.innerHeight / 2,
      0,
      s * 15,    // Mayor aceleración (era 10)
      s * 1,     // Menos fricción (era 2)
      0.3,       // Menos resistencia (era 0.5)
      16,
      0.7,       // Mayor aceleración rotacional (era 0.5)
      0.05,      // Menos fricción rotacional (era 0.085)
      0.3,       // Menos resistencia rotacional (era 0.5)
      0.2        // Menor umbral de rotación (era 0.3) = más sensible
    );
    var spinal = critter;
    
    // Cuello
    for (var i = 0; i < 6; i++) {
      spinal = new Segment(spinal, s * 4, 0, 3.1415 * 2 / 3, 0.8); // Más flexible (era 1.1)
      for (var ii = -1; ii <= 1; ii += 2) {
        var node = new Segment(spinal, s * 3, ii, 0.1, 1.5); // Más flexible (era 2)
        for (var iii = 0; iii < 3; iii++) {
          node = new Segment(node, s * 0.1, -ii * 0.1, 0.1, 1.5);
        }
      }
    }
    
    // Torso y patas
    for (var i = 0; i < legs; i++) {
      if (i > 0) {
        for (var ii = 0; ii < 6; ii++) {
          spinal = new Segment(spinal, s * 4, 0, 1.571, 1.2); // Más flexible (era 1.5)
          for (var iii = -1; iii <= 1; iii += 2) {
            var node = new Segment(spinal, s * 3, iii * 1.571, 0.1, 1.2); // Más flexible
            for (var iv = 0; iv < 3; iv++) {
              node = new Segment(node, s * 3, -iii * 0.3, 0.1, 1.5);
            }
          }
        }
      }
      for (var ii = -1; ii <= 1; ii += 2) {
        var node = new Segment(spinal, s * 12, ii * 0.785, 0, 8);
        node = new Segment(node, s * 16, -ii * 0.785, 6.28, 0.8); // Más flexible (era 1)
        node = new Segment(node, s * 16, ii * 1.571, 3.1415, 1.5); // Más flexible (era 2)
        for (var iii = 0; iii < 4; iii++) {
          new Segment(node, s * 4, (iii / 3 - 0.5) * 1.571, 0.1, 3); // Más flexible (era 4)
        }
        new LegSystem(node, 3, s * 16, critter, 4); // Mayor velocidad de pata (era s * 12)
      }
    }
    
    // Cola
    for (var i = 0; i < tail; i++) {
      spinal = new Segment(spinal, s * 4, 0, 3.1415 * 2 / 3, 0.8); // Más flexible (era 1.1)
      for (var ii = -1; ii <= 1; ii += 2) {
        var node = new Segment(spinal, s * 3, ii, 0.1, 1.5); // Más flexible (era 2)
        for (var iii = 0; iii < 3; iii++) {
          node = new Segment(node, s * 3 * (tail - i) / tail, -ii * 0.1, 0.1, 1.5);
        }
      }
    }
    
    setInterval(function() {
      time += 0.02;
      
      // Dibujar fondo y elementos de terror
      drawHorrorBackground();
      drawDragonSilhouette();
      
      // Dibujar criatura
      critter.follow(Input.mouse.x, Input.mouse.y);
    }, 16); // 60 FPS aproximadamente (era 33ms = 30 FPS)
  }
  
  var legNum = 3; // Tres pares de patas = 6 patas totales
  setupLizard(
    10 / Math.sqrt(legNum), // Mayor tamaño para movimientos más amplios
    legNum,
    Math.floor(20 + Math.random() * 10) // Cola larga
  );
</script>
</body>
</html>